"use strict";(self.webpackChunkeurynome_cloud_document=self.webpackChunkeurynome_cloud_document||[]).push([[709],{2203:(e,d,i)=>{i.r(d),i.d(d,{data:()=>c});const c={key:"v-96fd052e",path:"/documents/%E5%89%8D%E7%AB%AF%E4%BB%8B%E7%BB%8D.html",title:"前端概览",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"项目简介",slug:"项目简介",children:[{level:3,title:"为什么没有使用 Vue 3",slug:"为什么没有使用-vue-3",children:[]}]},{level:2,title:"主要特性",slug:"主要特性",children:[]},{level:2,title:"技术介绍",slug:"技术介绍",children:[{level:3,title:"Vuetify",slug:"vuetify",children:[]},{level:3,title:"Typescript",slug:"typescript",children:[]},{level:3,title:"Monorepo",slug:"monorepo",children:[]},{level:3,title:"Lerna",slug:"lerna",children:[]},{level:3,title:"Rollup",slug:"rollup",children:[]}]},{level:2,title:"模块说明",slug:"模块说明",children:[{level:3,title:"@hecate/h-bpmn-moddle",slug:"hecate-h-bpmn-moddle",children:[]},{level:3,title:"@hecate/h-button",slug:"hecate-h-button",children:[]},{level:3,title:"@hecate/h-table",slug:"hecate-h-table",children:[]},{level:3,title:"@hecate/plugins",slug:"hecate-plugins",children:[]},{level:3,title:"@hecate/utils",slug:"hecate-utils",children:[]},{level:3,title:"@herodotus/ui",slug:"herodotus-ui",children:[]}]}],filePathRelative:"documents/前端介绍.md",git:{updatedTime:1632924477e3,contributors:[{name:"herodotus",email:"pointer_v@qq.com",commits:1}]}}},6031:(e,d,i)=>{i.r(d),i.d(d,{default:()=>a});const c=(0,i(6252).uE)('<h1 id="前端概览" tabindex="-1"><a class="header-anchor" href="#前端概览" aria-hidden="true">#</a> 前端概览</h1><h2 id="项目简介" tabindex="-1"><a class="header-anchor" href="#项目简介" aria-hidden="true">#</a> 项目简介</h2><p><strong>Eurynome Cloud UI</strong> 是 <strong>Eurynome Cloud</strong> 后台管理界面。是前后端分离的、独立运行的前端应用。基于 Vue 2.0 和 Typescript 4.2.X 构建，是组件库式的、模块化的前端工程。</p><p>以 <code>Vuetify</code> 组件库为基础，依赖丰富的常用组件和 <code>Material Design</code> 的设计优势，让你无需大量美工工作的投入，就可以快速得到非常美观的界面功能。</p><h3 id="为什么没有使用-vue-3" tabindex="-1"><a class="header-anchor" href="#为什么没有使用-vue-3" aria-hidden="true">#</a> 为什么没有使用 Vue 3</h3><p>Vue 3 已经出来将近一年了，很期待使用其新特性，让代码更简洁、更规范、更高效。为什么现在没有使用 Vue 3，主要原因是本项目定位于使用 Vuetify 组件，Vuetify 3 正在开发中，所以目前的版本仍旧在使用 Vue 2。目前工程代码已经全部切换为Typescript，就是为了迎接 Vue 3 和 Vuetify 3 做前序准备。</p><h2 id="主要特性" tabindex="-1"><a class="header-anchor" href="#主要特性" aria-hidden="true">#</a> 主要特性</h2><ul><li><strong>Eurynome Cloud UI</strong>是基于 <code>Lerna</code> 和 <code>yarn workspaces</code> 构建的， 以 <code>Monorepo</code> 方式管理代码的项目。</li><li>基于 Vue 2.0 和 Typescript 4.2.X 构建。是组件库式的、模块化的前端工程。</li><li>共性组件采用 <code>Rollup</code> 进行编译，做了已有认知范围内，能够做到的所有性能优化处理</li><li>支持 Vue Webpack 方式编译，并对工程打包进行了深入优化。</li><li>浏览器本地存储采用 localForage，支持 IndexedDB，WebSQL 和 localStorage 三种存储模式</li></ul><h2 id="技术介绍" tabindex="-1"><a class="header-anchor" href="#技术介绍" aria-hidden="true">#</a> 技术介绍</h2><h3 id="vuetify" tabindex="-1"><a class="header-anchor" href="#vuetify" aria-hidden="true">#</a> Vuetify</h3><p>Vuetify 是一个用于 Vue.js 的 Material Design 组件框架。它的目标是提供所有必要的工具来创建美丽的内容丰富的应用程序。能够让没有任何设计技能的开发者创造出时尚的 Material 风格界面。</p><h4 id="为什么选择vuetify" tabindex="-1"><a class="header-anchor" href="#为什么选择vuetify" aria-hidden="true">#</a> 为什么选择Vuetify</h4><p><img src="/eurynome-cloud/images/vue/why-vuetify.png" alt="Why"></p><ul><li>与其他框架相比，<code>Vuetify</code>覆盖了几乎其他前端框架的功能，组件丰富，移动端和pc端能进行比较好的自适应。框架的可扩展性强，可以根据框架的组件，开发出更高效的组件。</li><li>基于<code>Vue cli</code>提供了 <code>Vuetify Plugin</code>，集成更加方便，基本上实现一键集成，一个命令就能集成，省去很多配置。</li><li>二次开发更加容易，基于 <code>Vuetify</code> 提供的框架进行二次开发，更加的容易。</li><li>组件按需加载， <code>Vuetify</code> 框架内置了组件的按需加载，只要引用 <code>Vuetify</code> 组件，都是按需加载，大大减轻了进一步处理的时间成本。</li><li><code>Vuetify</code> 与其他框架的集成，集成比较简单，以 <code>Nuxt</code> 框架的集成为例，能方便的进行集成，简单的集成，就能使用，并且和后台管理的功能页面使用无差别，可以加快使用的成本</li><li>框架的持续的更新升级，基本每周都有更新，框架组件更新及时。便于系统技术升级。</li></ul><h3 id="typescript" tabindex="-1"><a class="header-anchor" href="#typescript" aria-hidden="true">#</a> Typescript</h3><h4 id="什么是typescript" tabindex="-1"><a class="header-anchor" href="#什么是typescript" aria-hidden="true">#</a> 什么是TypeScript</h4><p><code>TypeScript</code> 是 <code>JavaScript</code> 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 <code>Microsoft</code> 开发，代码开源于 <code>GitHub</code> 上。</p><p><code>TypeScript</code> 是 <code>JavaScript</code> 的类型的超集，它可以编译成纯 <code>JavaScript</code>。编译出来的 <code>JavaScript</code> <code>可以运行在任何浏览器上。TypeScript</code> 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。</p><h4 id="为什么选择typescript" tabindex="-1"><a class="header-anchor" href="#为什么选择typescript" aria-hidden="true">#</a> 为什么选择TypeScript</h4><ul><li><p><code>TypeScript</code> 增加了代码的可读性和可维护性</p><ul><li>类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了</li><li>可以在编译阶段就发现大部分错误，这总比在运行时候出错好</li><li>增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等</li></ul></li><li><p><code>TypeScript</code> 非常包容</p><ul><li>TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可</li><li>即使不显式的定义类型，也能够自动做出类型推论</li><li>可以定义从简单到复杂的几乎一切类型</li><li>即使 TypeScript 编译报错，也可以生成 JavaScript 文件</li><li>兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取</li></ul></li><li><p><code>TypeScript</code> 拥有活跃的社区</p><ul><li>大部分第三方库都有提供给 <code>TypeScript</code> 的类型定义文件</li><li><code>Google</code> 开发的 <code>Angular2</code> 就是使用 <code>TypeScript</code> 编写的</li><li><code>TypeScript</code> 拥抱了 <code>ES6</code> 规范，也支持部分 <code>ESNext</code> 草案的规范</li></ul></li></ul><h4 id="typescript-的缺点" tabindex="-1"><a class="header-anchor" href="#typescript-的缺点" aria-hidden="true">#</a> TypeScript 的缺点</h4><p>任何事物都是有两面性的，我认为 TypeScript 的弊端在于：</p><ul><li>有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念</li><li>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本</li><li>集成到构建流程需要一些工作量</li><li>可能和一些库结合的不是很完美</li></ul><h3 id="monorepo" tabindex="-1"><a class="header-anchor" href="#monorepo" aria-hidden="true">#</a> Monorepo</h3><p><code>Monorepo</code> 是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块/包 (package)，不同于常见的每个模块建一个 repo</p><p><code>Monorepo</code> 和 <code>Multirepo</code> 是两种不同的源码管理理念，<code>Monorepo</code> 是把所有的相关项目都放在一个仓库中（例如：React, Angular, Babel, Jest, Umijs, ...<code>），Multirepo</code> 则是按模块把子项目拆分到多个仓库中（例如：Rollup, ...）。前者允许多元化发展（各项目可以有自己的构建工具、依赖管理策略、单元测试方法），后者希望集中管理，减少项目间的差异带来的沟通成本。</p><p><code>Monorepo</code> 最主要的好处是统一的工作流和 Code Sharing。比如我想看一个 pacakge 的代码、了解某段逻辑，不需要找它的 repo，直接就在当前 repo；当某个需求要修改多个 pacakge 时，不需要分别到各自的 repo 进行修改、测试、发版或者 npm link，直接在当前 repo 修改，统一测试、统一发版。只要搭建一套脚手架，就能管理（构建、测试、发布）多个 package。</p><h3 id="lerna" tabindex="-1"><a class="header-anchor" href="#lerna" aria-hidden="true">#</a> Lerna</h3><p><code>Lerna</code> 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。</p><h3 id="rollup" tabindex="-1"><a class="header-anchor" href="#rollup" aria-hidden="true">#</a> Rollup</h3><p><code>Rollup</code> 是 <code>JavaScript</code> 的模块 <code>bundler，可将一小段代码编译为更大或更复杂的内容，例如库或应用程序。</code></p><p>它对 <code>JavaScript</code> 的 <code>ES6</code> 修订版中包含的代码模块使用了新的标准化格式，而不是先前的特殊解决方案（例如 <code>CommonJS</code> 和 <code>AMD</code>）。ES 模块使用户可以自由，无缝地结合自己喜欢的库中最有用的单个函数。</p><h2 id="模块说明" tabindex="-1"><a class="header-anchor" href="#模块说明" aria-hidden="true">#</a> 模块说明</h2><p>Vue 相比传统 Javascript 开发，最大优势之一就是其强大的组件化和代码可复用化能力。Vue 极大的提升了前端代码编写的规范性和可维护性， <strong>Eurynome Cloud UI</strong> 采用 <code>Mononrepo</code> 组件库的方式构建前端工程，就是在已有 Vue 强大的组件化能力之上，进一步通用化前端工程代码。提升代码的开发速度和可维护性。</p><h3 id="hecate-h-bpmn-moddle" tabindex="-1"><a class="header-anchor" href="#hecate-h-bpmn-moddle" aria-hidden="true">#</a> @hecate/h-bpmn-moddle</h3><p>基于 <code>bpmn-js</code>、<code>bpmn-js-properties-panel</code>、<code>camunda-bpmn-moddle</code>、<code>diagram-js</code> 构建的标准化的 Bpmn 2.0 在线工作流编辑器。实现编辑器网格、放大缩小、Redo、Undo、模型导入、导出XML、SVG格式模型、部署至服务等功能。</p><p>以组件的形式定义的标准化组件，可在应用中直接引用。</p><h3 id="hecate-h-button" tabindex="-1"><a class="header-anchor" href="#hecate-h-button" aria-hidden="true">#</a> @hecate/h-button</h3><p>结合实际应用需求，基于 <code>Vuetify</code> Button 等组件封装的按钮组件。通用化按钮使用，减少代码中重复性代码量。</p><p>以组件的形式定义的标准化组件，可在应用中直接引用。</p><h3 id="hecate-h-table" tabindex="-1"><a class="header-anchor" href="#hecate-h-table" aria-hidden="true">#</a> @hecate/h-table</h3><p>结合实际应用需求，基于 <code>Vuetify</code> Table 等组件封装的按钮组件。通用化按钮使用，减少代码中重复性代码量。</p><p>以组件的形式定义的标准化组件，可在应用中直接引用。</p><h3 id="hecate-plugins" tabindex="-1"><a class="header-anchor" href="#hecate-plugins" aria-hidden="true">#</a> @hecate/plugins</h3><p>所有基于 <code>Vue</code> 和 <code>Vuetify</code> 构建的应用，都需要重复配置 <code>plugins</code> 等信息。<code>@hecate/plugins</code> 将常规工程中，常用的第三方插件 <code>plugins</code> 配置通用化，方便和简化新工程构建的配置。</p><p>以组件的形式定义的标准化组件，可在应用中直接引用。</p><h3 id="hecate-utils" tabindex="-1"><a class="header-anchor" href="#hecate-utils" aria-hidden="true">#</a> @hecate/utils</h3><p>将系统中通用的、工具类代码以及Lodash等工具统一封装，以组件的形式定义的标准化组件，可在应用中直接引用。</p><h3 id="herodotus-ui" tabindex="-1"><a class="header-anchor" href="#herodotus-ui" aria-hidden="true">#</a> @herodotus/ui</h3><p>基于 <code>Vuetify</code>、 <code>Vue</code>、 <code>Typescript</code> 构建的 <code>Eurynome Cloud</code> 前端工程。</p>',50),a={render:function(e,d){return c}}}}]);