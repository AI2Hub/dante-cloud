"use strict";(self.webpackChunkeurynome_cloud_document=self.webpackChunkeurynome_cloud_document||[]).push([[189],{7958:(e,r,a)=>{a.r(r),a.d(r,{data:()=>l});const l={key:"v-3297977c",path:"/basic-knowledge/postgresql.html",title:"为什么默认使用PostgreSQL数据库？",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"PostgreSQL VS MySQL",slug:"postgresql-vs-mysql",children:[{level:3,title:"MySQL",slug:"mysql",children:[]},{level:3,title:"PostgreSQL",slug:"postgresql",children:[]}]},{level:2,title:"PostgreSQL相对于MySQL的优势",slug:"postgresql相对于mysql的优势",children:[{level:3,title:"[1]、不仅仅是关系型数据库",slug:"_1-、不仅仅是关系型数据库",children:[]},{level:3,title:"[2]、支持地理信息处理扩展",slug:"_2-、支持地理信息处理扩展",children:[]},{level:3,title:"[3]、可以快速构建REST API",slug:"_3-、可以快速构建rest-api",children:[]},{level:3,title:"[4]、支持树状结构",slug:"_4-、支持树状结构",children:[]},{level:3,title:"[5]、有极其强悍的 SQL 编程能力",slug:"_5-、有极其强悍的-sql-编程能力",children:[]},{level:3,title:"[6]、外部数据源支持",slug:"_6-、外部数据源支持",children:[]},{level:3,title:"[7]、没有字符串长度限制",slug:"_7-、没有字符串长度限制",children:[]},{level:3,title:"[8]、支持图结构数据存储",slug:"_8-、支持图结构数据存储",children:[]},{level:3,title:"[9]、支持窗口函数",slug:"_9-、支持窗口函数",children:[]},{level:3,title:"[10]、对索引的支持更强",slug:"_10-、对索引的支持更强",children:[]},{level:3,title:"[11]、集群支持更好",slug:"_11-、集群支持更好",children:[]},{level:3,title:"[12]、事务隔离做的更好",slug:"_12-、事务隔离做的更好",children:[]},{level:3,title:"[13]、对于字符支持更好一些",slug:"_13-、对于字符支持更好一些",children:[]},{level:3,title:"[14]、对表连接支持较完整",slug:"_14-、对表连接支持较完整",children:[]},{level:3,title:"[15]、存储方式支持更大的数据量",slug:"_15-、存储方式支持更大的数据量",children:[]},{level:3,title:"[16]、时间精度更高",slug:"_16-、时间精度更高",children:[]},{level:3,title:"[17]、优化器的功能较完整",slug:"_17-、优化器的功能较完整",children:[]},{level:3,title:"[18]、序列支持更好",slug:"_18-、序列支持更好",children:[]},{level:3,title:"[19]、对子查询支持更好",slug:"_19-、对子查询支持更好",children:[]},{level:3,title:"[20]、增加列更加简单",slug:"_20-、增加列更加简单",children:[]}]},{level:2,title:"MySQL相对于PostgreSQL的优势",slug:"mysql相对于postgresql的优势",children:[{level:3,title:"[1]、MySQL比PostgreSQL更流行",slug:"_1-、mysql比postgresql更流行",children:[]},{level:3,title:"[2]、回滚实现更优",slug:"_2-、回滚实现更优",children:[]},{level:3,title:"[3]、在Windows上运行更可靠",slug:"_3-、在windows上运行更可靠",children:[]},{level:3,title:"[4]、线程模式相比进程模式的优势",slug:"_4-、线程模式相比进程模式的优势",children:[]},{level:3,title:"[5]、权限设置上更加完善",slug:"_5-、权限设置上更加完善",children:[]},{level:3,title:"[6]、存储引擎插件化机制",slug:"_6-、存储引擎插件化机制",children:[]},{level:3,title:"[7]、适应24/7运行",slug:"_7-、适应24-7运行",children:[]},{level:3,title:"[8]、更加试用于简单的场景",slug:"_8-、更加试用于简单的场景",children:[]}]},{level:2,title:"总结",slug:"总结",children:[]}],filePathRelative:"basic-knowledge/postgresql.md",git:{updatedTime:null,contributors:[]}}},4425:(e,r,a)=>{a.r(r),a.d(r,{default:()=>n});var l=a(6252);const s=(0,l.uE)('<h1 id="为什么默认使用postgresql数据库" tabindex="-1"><a class="header-anchor" href="#为什么默认使用postgresql数据库" aria-hidden="true">#</a> 为什么默认使用PostgreSQL数据库？</h1><h2 id="postgresql-vs-mysql" tabindex="-1"><a class="header-anchor" href="#postgresql-vs-mysql" aria-hidden="true">#</a> PostgreSQL VS MySQL</h2><p><img src="/eurynome-cloud/images/database/my-sql-vs-postgre-sql-compressed.jpg" alt="PostgreSQL VS MySQL"></p><p>MySQL的背后是一个成熟的商业公司，而PostgreSQL的背后是一个庞大的志愿开发组。这使得MySQL的开发过程更为慎重，而PostgreSQL的反应更为迅速。这样的两种背景直接导致了各自固有的优点和缺点。</p><h3 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> MySQL</h3><p>MySQL声称自己是最流行的开源数据库。LAMP中的M指的就是MySQL。构建在LAMP上的应用都会使用MySQL，如WordPress、Drupal等大多数php开源程序。MySQL最初是由MySQL AB开发的，然后在2008年以10亿美金的价格卖给了Sun公司，Sun公司又在2010年被Oracle收购。Oracle支持MySQL的多个版本：Standard、Enterprise、Classic、Cluster、Embedded与Community。其中有一些是免费下载的，另外一些则是收费的。其核心代码基于GPL许可，由于MySQL被控制在Oracle，社区担心会对MySQL的开源会有影响，所以开发了一些分支，比如： MariaDB和Percona。</p><h3 id="postgresql" tabindex="-1"><a class="header-anchor" href="#postgresql" aria-hidden="true">#</a> PostgreSQL</h3><p>PostgreSQL标榜自己是世界上最先进的开源数据库。PostgreSQL的一些粉丝说它能与Oracle相媲美，而且没有那么昂贵的价格和傲慢的客服。最初是1985年在加利福尼亚大学伯克利分校开发的，作为Ingres数据库的后继。PostgreSQL是完全由社区驱动的开源项目。它提供了单个完整功能的版本，而不像MySQL那样提供了多个不同的社区版、商业版与企业版。PostgreSQL基于自由的BSD/MIT许可，组织可以使用、复制、修改和重新分发代码，只需要提供一个版权声明即可。</p><h2 id="postgresql相对于mysql的优势" tabindex="-1"><a class="header-anchor" href="#postgresql相对于mysql的优势" aria-hidden="true">#</a> PostgreSQL相对于MySQL的优势</h2><h3 id="_1-、不仅仅是关系型数据库" tabindex="-1"><a class="header-anchor" href="#_1-、不仅仅是关系型数据库" aria-hidden="true">#</a> [1]、不仅仅是关系型数据库</h3><p>除了存储正常的数据类型外，还支持存储：</p><ul><li>array，不管是一位数组还是多为数组均支持</li><li>json(hStore)和jsonb，相比使用text存储接送要高效很多</li><li>json和jsonb之间的区别</li></ul><p>jsonb和json在更高的层面上看起来几乎是一样的，但在存储实现上是不同的。</p><ul><li>json存储完的文本，json列会每次都解析存储的值，它不支持索引，但你可以为查询创建表达式索引。</li><li>jsonb存储的二进制格式，避免了重新解析数据结构。它支持索引，这意味着你可以不使用指定的索引就能查询任何路径。</li></ul><p>当我们比较写入数据速度时，由于数据存储的方式的原因，jsonb会比json稍微的慢一点。json列会每次都解析存储的值，这意味着键的顺序要和输入的时候一样。但jsonb不同，以二进制格式存储且不保证键的顺序。因此，如果你有软件需要依赖键的顺序，jsonb可能不是你的应用的最佳选择。使用jsonb的优势还在于你可以轻易的整合关系型数据和非关系型数据， PostgreSQL对于mongodb这类的基于文档的数据库是个不小的威胁，毕竟如果一个表中只有一列数据的类型是半结构化的，没有必要为了迁就它而整个表的设计采用schemaless的结构。</p><h3 id="_2-、支持地理信息处理扩展" tabindex="-1"><a class="header-anchor" href="#_2-、支持地理信息处理扩展" aria-hidden="true">#</a> [2]、支持地理信息处理扩展</h3><p>PostGIS 为PostgreSQL提供了存储空间地理数据的支持，使PostgreSQL成为了一个空间数据库，能够进行空间数据管理、数量测量与几何拓扑分析。在功能上，和MYSQL对比，PostGIS具有下列优势：</p><p>O2O业务场景中的LBS业务使用PostgreSQL + PostGIS有无法比拟的优势。</p><h3 id="_3-、可以快速构建rest-api" tabindex="-1"><a class="header-anchor" href="#_3-、可以快速构建rest-api" aria-hidden="true">#</a> [3]、可以快速构建REST API</h3><p>PostgREST 可以方便的为任何 PostgreSQL 数据库提供完全的 RESTful API 服务。</p><h3 id="_4-、支持树状结构" tabindex="-1"><a class="header-anchor" href="#_4-、支持树状结构" aria-hidden="true">#</a> [4]、支持树状结构</h3><p>支持R-trees这样可扩展的索引类型，可以更方便地处理一些特殊数据。MySQL 处理树状的设计会很复杂, 而且需要写很多代码, 而 PostgreSQL 可以高效处理树结构。</p><h3 id="_5-、有极其强悍的-sql-编程能力" tabindex="-1"><a class="header-anchor" href="#_5-、有极其强悍的-sql-编程能力" aria-hidden="true">#</a> [5]、有极其强悍的 SQL 编程能力</h3><p>支持递归，有非常丰富的统计函数和统计语法支持。</p><p>MySQL：支持 CREATE PROCEDURE 和 CREATE FUNCTION 语句。存储过程可以用 SQL 和 C++ 编写。用户定义函数可以用 SQL、C 和 C++ 编写。 PostgreSQL：没有单独的存储过程，都是通过函数实现的。用户定义函数可以用 PL/pgSQL(专用的过程语言)、PL/Tcl、PL/Perl、PL/Python 、SQL 和 C 编写。</p><h3 id="_6-、外部数据源支持" tabindex="-1"><a class="header-anchor" href="#_6-、外部数据源支持" aria-hidden="true">#</a> [6]、外部数据源支持</h3><p>可以把 70 种外部数据源 (包括 Mysql, Oracle, CSV, hadoop …) 当成自己数据库中的表来查询。Postgres有一个针对这一难题的解决方案：一个名为“外部数据封装器(Foreign Data Wrapper，FDW)”的特性。该特性最初由PostgreSQL社区领袖Dave Page四年前根据SQL标准SQL/MED(SQL Management of External Data)开发。FDW提供了一个SQL接口，用于访问远程数据存储中的远程大数据对象，使DBA可以整合来自不相关数据源的数据，将它们存入Postgres数据库中的一个公共模型。这样，DBA就可以访问和操作其它系统管理的数据，就像在本地Postgres表中一样。例如，使用FDW for MongoDB，数据库管理员可以查询来自文档数据库的数据，并使用SQL将它与来自本地Postgres表的数据相关联。借助这种方法，用户可以将数据作为行、列或JSON文档进行查看、排序和分组。他们甚至可以直接从Postgres向源文档数据库写入(插入、更细或删除)数据，就像一个一体的无缝部署。也可以对Hadoop集群或MySQL部署做同样的事。FDW使Postgres可以充当企业的中央联合数据库或“Hub”。</p><h3 id="_7-、没有字符串长度限制" tabindex="-1"><a class="header-anchor" href="#_7-、没有字符串长度限制" aria-hidden="true">#</a> [7]、没有字符串长度限制</h3><p>一般关系型数据库的字符串有限定长度8k左右，无限长 TEXT 类型的功能受限，只能作为外部大数据访问。而PostgreSQL的 TEXT 类型可以直接访问，SQL语法内置正则表达式，可以索引，还可以全文检索，或使用xml xpath。MySQL 的各种text字段有不同的限制，要手动区分 small text, middle text, large text… PostgreSQL 没有这个限制，text 能支持各种大小。</p><h3 id="_8-、支持图结构数据存储" tabindex="-1"><a class="header-anchor" href="#_8-、支持图结构数据存储" aria-hidden="true">#</a> [8]、支持图结构数据存储</h3>',30),t=(0,l.Uk)("没有具体使用过，具体可以自己搜索下。"),i={href:"https://mp.weixin.qq.com/s/cjor82wgDu5gzDvTYpLDWw",target:"_blank",rel:"noopener noreferrer"},h=(0,l.Uk)("参考链接"),d=(0,l.uE)('<h3 id="_9-、支持窗口函数" tabindex="-1"><a class="header-anchor" href="#_9-、支持窗口函数" aria-hidden="true">#</a> [9]、支持窗口函数</h3><p>窗口函数提供跨行相关的当前查询行集执行计算的能力。仅当调用跟着OVER子句的聚集函数，作为窗口函数;否则它们作为常规的聚合函数。窗口也是一种分组，但和 group by 的分组不同。窗口，可以提供分组之外，还可以执行对每个窗口进行计算。可以想象成是group by 后，然后对每个分组进行计算，而不像Group by ，只是单纯地分组。MySQL 不支持 OVER 子句, 而PostgreSQL支持。OVER 子句能简单的解决 “每组取 top 5” 的这类问题。MySQL支持的SQL语法(ANSI SQL标准)的很小一部分。不支持递归查询、通用表表达式(Oracle的with 语句)或者窗口函数(分析函数)。</p><h3 id="_10-、对索引的支持更强" tabindex="-1"><a class="header-anchor" href="#_10-、对索引的支持更强" aria-hidden="true">#</a> [10]、对索引的支持更强</h3><p>PostgreSQL 的可以使用函数和条件索引，这使得PostgreSQL数据库的调优非常灵活，mysql就没有这个功能，条件索引在web应用中很重要。对于索引类型：</p><p>MySQL：取决于存储引擎。MyISAM：BTREE，InnoDB：BTREE。 PostgreSQL：支持 B-树、哈希、R-树和 Gist 索引。 InnoDB的表和索引都是按相同的方式存储。也就是说表都是索引组织表。这一般要求主键不能太长而且插入时的主键最好是按顺序递增，否则对性能有很大影响。PostgreSQL不存在这个问题。</p><p>索引类型方面，MySQL取决于存储引擎。MyISAM：BTREE，InnoDB：B+TREE。PostgreSQL支持 B-树、哈希、R-树和 Gist 索引。</p><h3 id="_11-、集群支持更好" tabindex="-1"><a class="header-anchor" href="#_11-、集群支持更好" aria-hidden="true">#</a> [11]、集群支持更好</h3><p>Mysql Cluster可能与你的想象有较大差异。开源的cluster软件较少。复制(Replication)功能是异步的并且有很大的局限性。例如，它是单线程的(single-threaded)，因此一个处理能力更强的Slave的恢复速度也很难跟上处理能力相对较慢的Master。</p><p>PostgreSQL有丰富的开源cluster软件支持。plproxy 可以支持语句级的镜像或分片，slony 可以进行字段级的同步设置，standby 可以构建WAL文件级或流式的读写分离集群，同步频率和集群策略调整方便，操作非常简单。</p><p>另外，PostgreSQL的主备复制属于物理复制，相对于MySQL基于binlog的逻辑复制，数据的一致性更加可靠，复制性能更高，对主机性能的影响也更小。对于WEB应用来说，复制的特性很重要，mysql到现在也是异步复制，pgsql可以做到同步，异步，半同步复制。还有mysql的同步是基于binlog复制，类似oracle golden gate,是基于stream的复制，做到同步很困难，这种方式更加适合异地复制，pgsql的复制基于wal，可以做到同步复制。同时，pgsql还提供stream复制。</p><h3 id="_12-、事务隔离做的更好" tabindex="-1"><a class="header-anchor" href="#_12-、事务隔离做的更好" aria-hidden="true">#</a> [12]、事务隔离做的更好</h3><p>MySQL 的事务隔离级别 repeatable read 并不能阻止常见的并发更新, 得加锁才可以, 但悲观锁会影响性能, 手动实现乐观锁又复杂. 而 PostgreSQL 的列里有隐藏的乐观锁 version 字段, 默认的 repeatable read 级别就能保证并发更新的正确性, 并且又有乐观锁的性能。</p><h3 id="_13-、对于字符支持更好一些" tabindex="-1"><a class="header-anchor" href="#_13-、对于字符支持更好一些" aria-hidden="true">#</a> [13]、对于字符支持更好一些</h3><p>MySQL 里需要 utf8mb4 才能显示 emoji 的坑, PostgreSQL 没这个坑。</p><h3 id="_14-、对表连接支持较完整" tabindex="-1"><a class="header-anchor" href="#_14-、对表连接支持较完整" aria-hidden="true">#</a> [14]、对表连接支持较完整</h3><p>对表连接支持较完整，MySQL只有一种表连接类型:嵌套循环连接(nested-loop),不支持排序-合并连接(sort-merge join)与散列连接(hash join)。PostgreSQL都支持。</p><h3 id="_15-、存储方式支持更大的数据量" tabindex="-1"><a class="header-anchor" href="#_15-、存储方式支持更大的数据量" aria-hidden="true">#</a> [15]、存储方式支持更大的数据量</h3><p>PostgreSQL主表采用堆表存放，MySQL采用索引组织表，能够支持比MySQL更大的数据量。</p><h3 id="_16-、时间精度更高" tabindex="-1"><a class="header-anchor" href="#_16-、时间精度更高" aria-hidden="true">#</a> [16]、时间精度更高</h3><p>MySQL对于时间、日期、间隔等时间类型没有秒以下级别的存储类型，而PostgreSQL可以精确到秒以下。</p><h3 id="_17-、优化器的功能较完整" tabindex="-1"><a class="header-anchor" href="#_17-、优化器的功能较完整" aria-hidden="true">#</a> [17]、优化器的功能较完整</h3><p>MySQL对复杂查询的处理较弱，查询优化器不够成熟，explain看执行计划的结果简单。性能优化工具与度量信息不足。</p><p>PostgreSQL很强大的查询优化器，支持很复杂的查询处理。explain返回丰富的信息。提供了一些性能视图，可以方便的看到发生在一个表和索引上的select、delete、update、insert统计信息，也可以看到cache命中率。网上有一个开源的pgstatspack工具。</p><h3 id="_18-、序列支持更好" tabindex="-1"><a class="header-anchor" href="#_18-、序列支持更好" aria-hidden="true">#</a> [18]、序列支持更好</h3><p>MySQL 不支持多个表从同一个序列中取 id, 而 PostgreSQL 可以。</p><h3 id="_19-、对子查询支持更好" tabindex="-1"><a class="header-anchor" href="#_19-、对子查询支持更好" aria-hidden="true">#</a> [19]、对子查询支持更好</h3><p>对子查询的支持。虽然在很多情况下在SQL语句中使用子查询效率低下，而且绝大多数情况下可以使用带条件的多表连接来替代子查询，但是子查询的存在在很多时候仍然不可避免。而且使用子查询的SQL语句与使用带条件的多表连接相比具有更高的程序可读性。几乎任何数据库的子查询 (subquery) 性能都比 MySQL 好。</p><h3 id="_20-、增加列更加简单" tabindex="-1"><a class="header-anchor" href="#_20-、增加列更加简单" aria-hidden="true">#</a> [20]、增加列更加简单</h3><p>MySQL表增加列，基本上是重建表和索引，会花很长时间。PostgreSQL表增加列，只是在数据字典中增加表定义，不会重建表.</p><h2 id="mysql相对于postgresql的优势" tabindex="-1"><a class="header-anchor" href="#mysql相对于postgresql的优势" aria-hidden="true">#</a> MySQL相对于PostgreSQL的优势</h2><h3 id="_1-、mysql比postgresql更流行" tabindex="-1"><a class="header-anchor" href="#_1-、mysql比postgresql更流行" aria-hidden="true">#</a> [1]、MySQL比PostgreSQL更流行</h3><p>流行对于一个商业软件来说，也是一个很重要的指标，流行意味着更多的用户，意味着经受了更多的考验，意味着更好的商业支持、意味着更多、更完善的文档资料。易用，很容易安装。第三方工具，包括可视化工具，让用户能够很容易入门。</p><h3 id="_2-、回滚实现更优" tabindex="-1"><a class="header-anchor" href="#_2-、回滚实现更优" aria-hidden="true">#</a> [2]、回滚实现更优</h3><p>innodb的基于回滚段实现的MVCC机制，相对PG新老数据一起存放的基于XID的MVCC机制，是占优的。新老数据一起存放，需要定时触发VACUUM，会带来多余的IO和数据库对象加锁开销，引起数据库整体的并发能力下降。而且VACUUM清理不及时，还可能会引发数据膨胀。</p><h3 id="_3-、在windows上运行更可靠" tabindex="-1"><a class="header-anchor" href="#_3-、在windows上运行更可靠" aria-hidden="true">#</a> [3]、在Windows上运行更可靠</h3><p>与PostgreSQL相比，MySQL更适宜在Windows环境下运行。MySQL作为一个本地的Windows应用程序运行(在 NT/Win2000/WinXP下，是一个服务)，而PostgreSQL是运行在Cygwin模拟环境下。PostgreSQL在Windows下运行没有MySQL稳定，应该是可以想象的。</p><h3 id="_4-、线程模式相比进程模式的优势" tabindex="-1"><a class="header-anchor" href="#_4-、线程模式相比进程模式的优势" aria-hidden="true">#</a> [4]、线程模式相比进程模式的优势</h3><p>MySQL使用了线程，而PostgreSQL使用的是进程。在不同线程之间的环境转换和访问公用的存储区域显然要比在不同的进程之间要快得多。</p><p>进程模式对多CPU利用率比较高。进程模式共享数据需要用到共享内存，而线程模式数据本身就是在进程空间内都是共享的，不同线程访问只需要控制好线程之间的同步。 线程模式对资源消耗比较少。所以MySQL能支持远比PostgreSQL多的更多的连接。但PostgreSQL中有优秀的连接池软件软件，如pgbouncer和pgpool，所以通过连接池也可以支持很多的连接。</p><h3 id="_5-、权限设置上更加完善" tabindex="-1"><a class="header-anchor" href="#_5-、权限设置上更加完善" aria-hidden="true">#</a> [5]、权限设置上更加完善</h3><p>MySQL在权限系统上比PostgreSQL某些方面更为完善。PostgreSQL只支持对于每一个用户在一个数据库上或一个数据表上的 INSERT、SELECT和UPDATE/DELETE的授权，而MySQL允许你定义一整套的不同的数据级、表级和列级的权限。对于列级的权限， PostgreSQL可以通过建立视图，并确定视图的权限来弥补。MySQL还允许你指定基于主机的权限，这对于目前的PostgreSQL是无法实现的，但是在很多时候，这是有用的。</p><h3 id="_6-、存储引擎插件化机制" tabindex="-1"><a class="header-anchor" href="#_6-、存储引擎插件化机制" aria-hidden="true">#</a> [6]、存储引擎插件化机制</h3><p>MySQL的存储引擎插件化机制，使得它的应用场景更加广泛，比如除了innodb适合事务处理场景外，myisam适合静态数据的查询场景。</p><h3 id="_7-、适应24-7运行" tabindex="-1"><a class="header-anchor" href="#_7-、适应24-7运行" aria-hidden="true">#</a> [7]、适应24/7运行</h3><p>MySQL可以适应24/7运行。在绝大多数情况下，你不需要为MySQL运行任何清除程序。PostgreSQL目前仍不完全适应24/7运行，这是因为你必须每隔一段时间运行一次VACUUM。</p><h3 id="_8-、更加试用于简单的场景" tabindex="-1"><a class="header-anchor" href="#_8-、更加试用于简单的场景" aria-hidden="true">#</a> [8]、更加试用于简单的场景</h3><p>PostgreSQL只支持堆表，不支持索引组织表，Innodb只支持索引组织表。</p><ul><li>索引组织表的优势：表内的数据就是按索引的方式组织，数据是有序的，如果数据都是按主键来访问，那么访问数据比较快。而堆表，按主键访问数据时，是需要先按主键索引找到数据的物理位置。</li><li>索引组织表的劣势：索引组织表中上再加其它的索引时，其它的索引记录的数据位置不再是物理位置，而是主键值，所以对于索引组织表来说，主键的值不能太大，否则占用的空间比较大。</li></ul><p>对于索引组织表来说，如果每次在中间插入数据，可能会导致索引分裂，索引分裂会大大降低插入的性能。所以对于使用innodb来说，我们一般最好让主键是一个无意义的序列，这样插入每次都发生在最后，以避免这个问题。 由于索引组织表是按一个索引树，一般它访问数据块必须按数据块之间的关系进行访问，而不是按物理块的访问数据的，所以当做全表扫描时要比堆表慢很多，这可能在OLTP中不明显，但在数据仓库的应用中可能是一个问题。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>MySQL从一开始就没有打算做所有事情，因而它在功能方面有一定的局限性，并不能满足一些先进应用程序的要求。MySQL对某些功能(例如引用、事务、审计等)的实现方式使得它与其他的关系型数据库相比缺少了一些可靠性。对于简单繁重的读取操作，使用PostgreSQL可能有点小题大做，同时性能也比MySQL这样的同类产品要差。除非你需要绝对的数据完整性，ACID遵从性或者设计复杂，否则PostgreSQL对于简单的场景而言有点多余。</p><p>如何你确定只在MySQL和PostgreSQL中进行选择，以下规则总是有效的：</p><ul><li>如果你的操作系统是Windows，你应该使用MySQL。</li><li>当绝对需要可靠性和数据完整性的时候，PostgreSQL是更好的选择。</li><li>如果需要数据库执行定制程序，那么可扩展的PostgreSQL是更好的选择。</li><li>你的应用处理的是地理数据，由于R-TREES的存在，你应该使用PostgreSQL。</li><li>如果你对数据库并不了十分了解，甚至不知道事务、存储过程等究竟是什么，你应该使用MySQL。</li></ul>',53),n={render:function(e,r){const a=(0,l.up)("OutboundLink");return(0,l.wg)(),(0,l.iD)(l.HY,null,[s,(0,l._)("p",null,[t,(0,l._)("a",i,[h,(0,l.Wm)(a)])]),d],64)}}}}]);